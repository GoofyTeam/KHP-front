enum AllergenEnum {
  gluten
  fruits_a_coque
  crustaces
  celeri
  oeufs
  moutarde
  poisson
  soja
  lait
  sulfites
  sesame
  lupin
  arachides
  mollusques
}

type Category {
  """Unique primary key."""
  id: ID!

  """Category name."""
  name: String!

  """Ingredients in this category."""
  ingredients: [Ingredient!]!

  """Preparations in this category."""
  preparations: [Preparation!]!

  """The company that owns this category."""
  company: Company!

  """Shelf life durations by location type."""
  shelfLives: [CategoryShelfLife!]!

  """When the Category was created."""
  created_at: DateTime!

  """When the Category was last updated."""
  updated_at: DateTime!
}

"""A paginated list of Category items."""
type CategoryPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Category items."""
  data: [Category!]!
}

type CategoryShelfLife {
  """The location type for this shelf life."""
  locationType: LocationType!

  """Shelf life in hours for the category at this location type."""
  shelf_life_hours: Int!
}

type Company {
  """Unique primary key."""
  id: ID!

  """Company name."""
  name: String!

  """Preparations associated with this company."""
  preparations: [Preparation!]!
  categories: [Category!]!
  locations: [Location!]!

  """Types de localisation associés à cette entreprise."""
  locationTypes: [LocationType!]!

  """Langue préférée pour les données OpenFoodFacts (fr ou en)."""
  open_food_facts_language: String

  """Paramètres visibles publiquement pour la carte des menus."""
  public_menu_settings: PublicMenuSettings!

  """When the company was created."""
  created_at: DateTime!

  """When the company was last updated."""
  updated_at: DateTime!
}

"""Champs disponibles pour le tri des entreprises."""
enum CompanyOrderByField {
  ID
  NAME
  CREATED_AT
  UPDATED_AT
}

"""Options de tri pour les entreprises."""
input CompanyOrderByOrderByClause {
  """Champ sur lequel effectuer le tri."""
  field: CompanyOrderByField!

  """Direction du tri."""
  order: SortOrder!
}

"""A paginated list of Company items."""
type CompanyPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Company items."""
  data: [Company!]!
}

scalar Date

"""
A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`.
"""
scalar DateTime

type Ingredient {
  """Unique primary key."""
  id: ID!

  """Ingredient name."""
  name: String!

  """Unit of measurement for the ingredient."""
  unit: UnitEnum!

  """Quantity for one unit of the ingredient."""
  base_quantity: Float!

  """Unit for the base quantity of the ingredient."""
  base_unit: UnitEnum!

  """Optional minimum stock quantity before alerting."""
  threshold: Float

  """Allergens contained in the ingredient."""
  allergens: [AllergenEnum!]!
  quantities: [IngredientQuantity!]!

  """The company that owns this ingredient."""
  company: Company!
  category: Category!
  image_url: String

  """Historique des mouvements de stock pour cet ingrédient"""
  stockMovements(orderBy: [StockMovementOrderByClause!]): [StockMovement!]!
  withdrawals_today_count: Int!

  """Number of withdrawals for this ingredient today."""
  withdrawals_this_week_count: Int!

  """Number of withdrawals for this ingredient this week."""
  withdrawals_this_month_count: Int!

  """When the ingredient was created."""
  created_at: DateTime!

  """When the ingredient was last updated."""
  updated_at: DateTime!
}

input IngredientOrderByClause {
  column: IngredientOrderByField!
  order: SortOrder! = ASC
}

enum IngredientOrderByField {
  ID
  NAME
  CREATED_AT
  UPDATED_AT
  WITHDRAWALS_TODAY
  WITHDRAWALS_THIS_WEEK
  WITHDRAWALS_THIS_MONTH
}

"""A paginated list of Ingredient items."""
type IngredientPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Ingredient items."""
  data: [Ingredient!]!
}

type IngredientQuantity {
  """Le stock de l'ingrédient."""
  quantity: Float!

  """La localisation de ce stock."""
  location: Location!
}

scalar JSON

type Location {
  """Unique primary key."""
  id: ID!

  """Location name."""
  name: String!

  """Location company."""
  company: Company!

  """Type de localisation (Congélateur, Réfrigérateur, etc.)"""
  locationType: LocationType

  """When the location was created."""
  created_at: DateTime!

  """When the location was last updated."""
  updated_at: DateTime!

  """Ingredients stored in this location."""
  ingredients: [Ingredient!]!
}

"""Champs disponibles pour le tri des emplacements."""
enum LocationOrderByField {
  ID
  NAME
  CREATED_AT
  UPDATED_AT
}

"""Options de tri pour les emplacements."""
input LocationOrderByOrderByClause {
  """Champ sur lequel effectuer le tri."""
  field: LocationOrderByField!

  """Direction du tri."""
  order: SortOrder!
}

"""A paginated list of Location items."""
type LocationPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Location items."""
  data: [Location!]!
}

"""Type de localisation pour organiser les emplacements de stockage"""
type LocationType {
  """Identifiant unique."""
  id: ID!

  """Nom du type de localisation."""
  name: String!

  """Indique si c'est un type par défaut (non modifiable)."""
  is_default: Boolean!

  """L'entreprise à laquelle appartient ce type."""
  company: Company!

  """Emplacements utilisant ce type de localisation."""
  locations: [Location!]!

  """Date de création du type."""
  created_at: DateTime!

  """Date de dernière mise à jour du type."""
  updated_at: DateTime!
}

"""Champs disponibles pour le tri des types de localisation."""
enum LocationTypeOrderByField {
  ID
  NAME
  IS_DEFAULT
  CREATED_AT
  UPDATED_AT
}

"""Options de tri pour les types de localisation."""
input LocationTypeOrderByOrderByClause {
  """Champ sur lequel effectuer le tri."""
  field: LocationTypeOrderByField!

  """Direction du tri."""
  order: SortOrder!
}

"""A paginated list of LocationType items."""
type LocationTypePaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of LocationType items."""
  data: [LocationType!]!
}

"""Représente une perte d'ingrédient ou de préparation."""
type Loss {
  """Identifiant unique."""
  id: ID!

  """Type d'entité concernée par cette perte (ingredient ou preparation)."""
  loss_item_type: String!

  """ID de l'entité concernée."""
  loss_item_id: ID!

  """L'emplacement où la perte a eu lieu."""
  location: Location!

  """L'entreprise à laquelle appartient cette perte."""
  company: Company!

  """L'utilisateur qui a enregistré la perte."""
  user: User

  """Quantité perdue."""
  quantity: Float!

  """Raison de la perte."""
  reason: String!

  """Date et heure de création de la perte."""
  created_at: DateTime!

  """Date et heure de dernière mise à jour de la perte."""
  updated_at: DateTime!
}

"""Statistiques des pertes par type."""
type LossesStats {
  ingredient: Float!
  preparation: Float!
  total: Float!
}

input LossOrderByClause {
  field: LossOrderByField!
  order: SortOrder!
}

enum LossOrderByField {
  ID
  QUANTITY
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of Loss items."""
type LossPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Loss items."""
  data: [Loss!]!
}

"""Raison de perte prédéfinie pour une entreprise."""
type LossReason {
  """Identifiant unique."""
  id: ID!

  """Nom de la raison."""
  name: String!

  """Entreprise associée."""
  company: Company!

  """Date de création."""
  created_at: DateTime!

  """Date de mise à jour."""
  updated_at: DateTime!
}

"""Type représentant une unité de mesure"""
type MeasurementUnitType {
  """Valeur utilisée en interne (ex: 'kg', 'L')"""
  value: String!

  """Libellé français (ex: 'Kilogramme (kg)')"""
  label: String!

  """Catégorie de l'unité (masse, volume ou unité)"""
  category: String!
}

type Menu {
  id: ID!
  name: String!
  description: String
  image_url: String
  is_a_la_carte: Boolean!
  service_type: MenuServiceTypeEnum!
  is_returnable: Boolean!
  available(quantity: Int! = 1): Boolean!
  type: String!
  menu_type_id: ID!
  public_priority: Int!
  menu_type: MenuType
  price: Float!
  categories: [MenuCategory!]!
  allergens: [AllergenEnum!]!
  items: [MenuItem!]!
  created_at: DateTime!
  updated_at: DateTime!
}

type MenuCategory {
  """Unique primary key."""
  id: ID!

  """Category name."""
  name: String!

  """Menus in this category."""
  menus: [Menu!]!

  """The company that owns this category."""
  company: Company!

  """When the category was created."""
  created_at: DateTime!

  """When the category was last updated."""
  updated_at: DateTime!
}

"""A paginated list of MenuCategory items."""
type MenuCategoryPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of MenuCategory items."""
  data: [MenuCategory!]!
}

type MenuItem {
  id: ID!
  location: Location!
  quantity: Float!
  unit: UnitEnum!
  entity: MenuItemEntity!
}

union MenuItemEntity = Ingredient | Preparation

"""A paginated list of Menu items."""
type MenuPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Menu items."""
  data: [Menu!]!
}

enum MenuServiceTypeEnum {
  PREP
  DIRECT
}

type MenuType {
  id: ID!
  name: String!
  public_index: Int!
}

"""Représente un produit alimentaire issu d'OpenFoodFacts"""
type OpenFoodFactsProduct {
  barcode: String
  product_name: String
  base_quantity: Float
  unit: String
  categories: [String]
  imageUrl: String
  is_already_in_database: Boolean
  ingredient_id: ID
}

"""Représente une commande passée dans l'établissement."""
type Order {
  """Identifiant unique."""
  id: ID!

  """Table associée à la commande."""
  table: Table!

  """Entreprise propriétaire de la commande."""
  company: Company!

  """Utilisateur qui a créé la commande."""
  user: User!

  """Statut actuel de la commande."""
  status: OrderStatusEnum!

  """Horodatage du passage de la commande en statut PENDING."""
  pending_at: DateTime

  """Horodatage du service de la commande."""
  served_at: DateTime

  """Horodatage du paiement de la commande."""
  payed_at: DateTime

  """Horodatage de l'annulation éventuelle."""
  canceled_at: DateTime

  """
  Prix total TTC calculé à partir des menus de toutes les étapes (prix × quantité).
  """
  price: Float!

  """Étapes associées à la commande."""
  steps: [OrderStep!]!

  """Date de création de la commande."""
  created_at: DateTime!

  """Date de dernière mise à jour."""
  updated_at: DateTime!
}

"""Allows ordering a list of records."""
input OrderByClause {
  """The column that is used for ordering."""
  column: String!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""
Aggregate functions when ordering by a relation without specifying a column.
"""
enum OrderByRelationAggregateFunction {
  """Amount of items."""
  COUNT
}

"""
Aggregate functions when ordering by a relation that may specify a column.
"""
enum OrderByRelationWithColumnAggregateFunction {
  """Average."""
  AVG

  """Minimum."""
  MIN

  """Maximum."""
  MAX

  """Sum."""
  SUM

  """Amount of items."""
  COUNT
}

"""Options de tri disponibles pour les commandes."""
input OrderOrderByClause {
  """Colonne utilisée pour le tri."""
  column: OrderOrderByField!

  """Direction du tri."""
  order: SortOrder! = ASC
}

"""Colonnes triables pour les commandes."""
enum OrderOrderByField {
  ID
  STATUS
  TABLE_ID
  USER_ID
  PENDING_AT
  SERVED_AT
  PAYED_AT
  CANCELED_AT
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of Order items."""
type OrderPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Order items."""
  data: [Order!]!
}

"""Statistiques agrégées sur les commandes."""
type OrdersStats {
  pending: Int!
  served: Int!
  payed: Int!
  canceled: Int!
  total: Int!
  revenue: Float!
}

enum OrderStatusEnum {
  PENDING
  SERVED
  PAYED
  CANCELED
}

"""Étape individuelle d'une commande."""
type OrderStep {
  """Identifiant unique."""
  id: ID!

  """Commande à laquelle appartient l'étape."""
  order: Order!

  """Position de l'étape dans le flux de service."""
  position: Int!

  """Statut actuel de l'étape."""
  status: OrderStepStatusEnum!

  """Horodatage du service de l'étape."""
  served_at: DateTime

  """
  Prix TTC de l'étape calculé en sommant prix × quantité des menus associés.
  """
  price: Float!

  """Menus associés à cette étape."""
  stepMenus: [StepMenu!]!

  """Menus liés via la relation pivot."""
  menus: [Menu!]!

  """Date de création de l'étape."""
  created_at: DateTime!

  """Date de dernière mise à jour."""
  updated_at: DateTime!
}

"""Options de tri disponibles pour les étapes de commande."""
input OrderStepOrderByClause {
  """Colonne utilisée pour le tri."""
  column: OrderStepOrderByField!

  """Direction du tri."""
  order: SortOrder! = ASC
}

"""Colonnes triables pour les étapes de commande."""
enum OrderStepOrderByField {
  ID
  ORDER_ID
  POSITION
  STATUS
  SERVED_AT
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of OrderStep items."""
type OrderStepPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of OrderStep items."""
  data: [OrderStep!]!
}

enum OrderStepStatusEnum {
  IN_PREP
  READY
  SERVED
}

"""Information about pagination using a fully featured paginator."""
type PaginatorInfo {
  """Number of items in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the first item in the current page."""
  firstItem: Int

  """Are there more pages after this one?"""
  hasMorePages: Boolean!

  """Index of the last item in the current page."""
  lastItem: Int

  """Index of the last available page."""
  lastPage: Int!

  """Number of items per page."""
  perPage: Int!

  """Number of total available items."""
  total: Int!
}

type Perishable {
  id: ID!
  ingredient: Ingredient!
  location: Location!
  quantity: Float!
  is_read: Boolean!
  expiration_at: DateTime!
  created_at: DateTime!
  updated_at: DateTime!
}

enum PerishableFilter {
  FRESH
  SOON
  EXPIRED
}

type Preparation {
  """Unique primary key."""
  id: ID!

  """Preparation name."""
  name: String!

  """Unit of measurement for the preparation."""
  unit: UnitEnum!

  """Quantity for one unit of the preparation."""
  base_quantity: Float!

  """Unit for the base quantity of the preparation."""
  base_unit: UnitEnum!

  """Allergens contained in this preparation."""
  allergens: [AllergenEnum!]!

  """The company that produces this preparation."""
  company: Company!

  """Threshold below which the preparation is considered understocked."""
  threshold: Float
  entities: [PreparationEntity!]!
  locations: [Location!]!

  """The categories associated with this preparation."""
  categories: [Category!]!
  quantities: [PreparationQuantity!]!
  preparable_quantity: PreparationPreparableQuantity!
  image_url: String

  """Historique des mouvements de stock pour cette préparation"""
  stockMovements: [StockMovement!]!
  withdrawals_today_count: Int!

  """Number of withdrawals for this ingredient today."""
  withdrawals_this_week_count: Int!

  """Number of withdrawals for this ingredient this week."""
  withdrawals_this_month_count: Int!

  """When the preparation was created."""
  created_at: DateTime!

  """When the preparation was last updated."""
  updated_at: DateTime!
}

type PreparationEntity {
  id: ID!
  entity: PreparationEntityItem!
  preparation: Preparation!
  location: Location!
  quantity: Float!
  unit: UnitEnum!
}

union PreparationEntityItem = Ingredient | Preparation

input PreparationOrderByClause {
  column: PreparationOrderByField!
  order: SortOrder! = ASC
}

enum PreparationOrderByField {
  ID
  NAME
  CREATED_AT
  UPDATED_AT
  WITHDRAWALS_TODAY
  WITHDRAWALS_THIS_WEEK
  WITHDRAWALS_THIS_MONTH
}

"""A paginated list of Preparation items."""
type PreparationPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Preparation items."""
  data: [Preparation!]!
}

type PreparationPreparableQuantity {
  """Quantité maximale préparable avec le stock actuel."""
  quantity: Float!

  """Unité associée à la préparation."""
  unit: UnitEnum!
}

type PreparationQuantity {
  """Le stock de la préparation."""
  quantity: Float!

  """La localisation de ce stock."""
  location: Location!
}

type PublicMenuSettings {
  """Identifiant public unique pour partager la carte du restaurant."""
  public_menu_card_url: String!

  """
  Affiche aussi les menus qui n'ont pas assez de stock sur la carte publique.
  """
  show_out_of_stock_menus_on_card: Boolean!

  """Affiche les images des menus sur la carte publique."""
  show_menu_images: Boolean!
}

type Query {
  """
  Recherche un produit par code-barres ou par mots-clés.
  Si 'barcode' est fourni, la recherche se fait par code-barres.
  Sinon, la recherche se fait par mots-clés.
  """
  search(barcode: String, keyword: String, page: Int = 1, pageSize: Int = 20): OpenFoodFactsProduct

  """Liste les allergènes disponibles"""
  allergens: [AllergenEnum!]!

  """Find a single Category (only if it belongs to the current company)."""
  Category(
    """Search by primary key."""
    id: ID

    """Search by Category name."""
    name: String
  ): Category

  """Find a single company by an identifying attribute."""
  company(
    """Search by primary key."""
    id: ID

    """Search by company name."""
    name: String
  ): Company

  """Find a single ingredient (only if it belongs to the current company)."""
  ingredient(
    """Search by primary key."""
    id: ID

    """Search by ingredient name."""
    name: String

    """Search by ingredient barcode."""
    barcode: String
  ): Ingredient

  """List ingredients that dropped below their defined threshold."""
  ingredientTreshold(
    """Filtrer selon un ou plusieurs emplacements."""
    locationIds: [ID!]
  ): [Ingredient!]!

  """Find a single location (only if it belongs to the current company)."""
  location(
    """Search by primary key."""
    id: ID

    """Search by location name."""
    name: String
  ): Location

  """
  Trouve un type de localisation spécifique (seulement s'il appartient à l'entreprise actuelle).
  """
  locationType(
    """Recherche par identifiant."""
    id: ID

    """Recherche par nom du type."""
    name: String
  ): LocationType
  lossesStats(start_date: DateTime, end_date: DateTime): LossesStats!

  """Liste les raisons de perte de l'entreprise actuelle."""
  lossReasons: [LossReason!]!

  """Liste les unités de mesure disponibles"""
  measurementUnits: [MeasurementUnitType!]!
  menu(id: ID!): Menu
  menuTypes: [MenuType!]!

  """
  Find a single MenuCategory (only if it belongs to the current company).
  """
  menuCategory(
    """Search by primary key."""
    id: ID

    """Search by category name."""
    name: String
  ): MenuCategory

  """
  Récupère une commande précise (si elle appartient à l'entreprise courante).
  """
  order(id: ID!): Order

  """Retourne les statistiques des commandes sur une période."""
  ordersStats(statuses: [OrderStatusEnum!], table_id: ID, user_id: ID, start_date: DateTime, end_date: DateTime): OrdersStats!

  """Récupère une étape précise."""
  orderStep(id: ID!): OrderStep
  perishables(filter: PerishableFilter = FRESH, is_read: Boolean): [Perishable!]!
  nonPerishableIngredients: [Ingredient!]!

  """Trouve une preparation (et seulement si elle appartient à ma company)"""
  preparation(id: ID, name: String): Preparation

  """List preparations that dropped below their defined threshold."""
  PreparationsThreshold(
    """Filtrer selon un ou plusieurs emplacements."""
    locationIds: [ID!]
  ): [Preparation!]!

  """Liste les quick access de l’entreprise courante, triés par index."""
  quickAccesses: [QuickAccess!]!
  room(id: ID, code: String): Room
  searchInStock(keyword: String!): [SearchResult!]!

  """Récupère une ligne précise."""
  stepMenu(id: ID!): StepMenu
  table(id: ID!): Table

  """Find a single user by an identifying attribute."""
  user(
    """Search by primary key."""
    id: ID

    """Search by email address."""
    email: String
  ): User

  """The currently authenticated user."""
  me: User!

  """List categories for the current company."""
  categories(
    """Search by category name. Accepts SQL LIKE wildcards `%` and `_`."""
    search: String

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): CategoryPaginator!

  """List multiple companies."""
  companies(
    """Filters by name. Accepts SQL LIKE wildcards `%` and `_`."""
    name: String

    """Options de tri des résultats."""
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): CompanyPaginator!

  """List ingredients for the current company."""
  ingredients(
    """Filter by a search term. Accepts SQL LIKE wildcards `%` and `_`."""
    search: String
    unit: UnitEnum

    """Filtrer par un ou plusieurs identifiants d'emplacements."""
    locationIds: [ID!]

    """Filtrer par une ou plusieurs catégories."""
    categoryIds: [ID!]

    """Filtrer par un ou plusieurs allergènes."""
    allergens: [AllergenEnum!]

    """Options de tri des ingrédients"""
    orderBy: [OrderByClause!]

    """Get ingredient by its barcode."""
    barcode: String

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): IngredientPaginator!

  """List locations for the current company."""
  locations(
    """
    Recherche par nom, insensible aux accents et à la casse. Accepte les caractères génériques SQL LIKE `%` et `_`.
    """
    search: String

    """Filter by location type ID."""
    locationTypeId: ID

    """Options de tri des résultats."""
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): LocationPaginator!

  """Liste les types de localisation pour l'entreprise actuelle."""
  locationTypes(
    """
    Recherche par nom, insensible aux accents et à la casse. Accepte les caractères génériques SQL LIKE `%` et `_`.
    """
    search: String

    """Filtre pour afficher uniquement les types par défaut."""
    is_default: Boolean

    """Options de tri des résultats."""
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): LocationTypePaginator!

  """Liste les pertes pour l'entreprise actuelle."""
  losses(
    loss_item_type: String
    loss_item_id: ID
    location_id: ID
    start_date: DateTime
    end_date: DateTime
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): LossPaginator!
  menus(
    """Filtrer par un ou plusieurs allergènes."""
    allergens: [AllergenEnum!]

    """Filtrer par une ou plusieurs catégories (IDs)."""
    category_ids: [ID!]

    """Filtrer par un ou plusieurs types."""
    types: [String!]

    """Filtrer par type de service (PREP, DIRECT)."""
    service_types: [MenuServiceTypeEnum!]

    """Filtrer par un range de prix [min, max]."""
    price_between: [Float!]

    """Filtrer par disponibilité."""
    available: Boolean

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): MenuPaginator!

  """List menu categories for the current company."""
  menuCategories(
    """Search by category name. Accepts SQL LIKE wildcards `%` and `_`."""
    search: String

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): MenuCategoryPaginator!

  """Liste les commandes pour l'entreprise courante."""
  orders(
    """Filtre par statut (plusieurs valeurs possibles)."""
    statuses: [OrderStatusEnum!]

    """Filtre par identifiant de table."""
    table_id: ID

    """Filtre par identifiant d'utilisateur."""
    user_id: ID

    """Filtre par date de création minimale."""
    start_date: DateTime

    """Filtre par date de création maximale."""
    end_date: DateTime

    """Options de tri des commandes."""
    orderBy: [QueryOrdersOrderByOrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): OrderPaginator!

  """Liste les étapes de commandes."""
  orderSteps(
    """Filtre par identifiant de commande."""
    order_id: ID

    """Filtre par statut."""
    statuses: [OrderStepStatusEnum!]

    """Options de tri des étapes."""
    orderBy: [QueryOrderStepsOrderByOrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): OrderStepPaginator!

  """Liste les preparations de ma company uniquement"""
  preparations(
    """
    Recherche par nom, insensible aux accents et à la casse. Accepte les caractères génériques SQL LIKE `%` et `_`.
    """
    search: String

    """Filtre par unité de mesure avec opérateur LIKE."""
    unit: UnitEnum

    """Filtrer par un ou plusieurs identifiants d'emplacements."""
    locationIds: [ID!]

    """Filtrer par une ou plusieurs catégories."""
    categoryIds: [ID!]

    """Filtrer par un ou plusieurs allergènes."""
    allergens: [AllergenEnum!]

    """Options de tri des préparations"""
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): PreparationPaginator!
  rooms(
    search: String
    code: String
    orderBy: [QueryRoomsOrderByOrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): RoomPaginator!

  """Liste les menus associés aux étapes de commandes."""
  stepMenus(
    """Filtre par identifiant d'étape de commande."""
    order_step_id: ID

    """Filtre par identifiant de menu."""
    menu_id: ID

    """Filtre par statut."""
    statuses: [StepMenuStatusEnum!]

    """Options de tri des lignes."""
    orderBy: [QueryStepMenusOrderByOrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): StepMenuPaginator!

  """Liste les mouvements de stock pour l'entreprise actuelle."""
  stockMovements(
    """Filtre par type de mouvement."""
    type: String

    """Filtre par ID d'emplacement."""
    location_id: ID

    """Filtre par type d'entité concernée."""
    trackable_type: String

    """Filtre par ID d'entité concernée."""
    trackable_id: ID

    """Filtre par date de début."""
    start_date: DateTime

    """Filtre par date de fin."""
    end_date: DateTime

    """Options de tri des résultats."""
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): StockMovementPaginator!
  tables(
    search: String
    roomId: ID
    orderBy: [QueryTablesOrderByOrderByClause!]

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): TablePaginator!

  """List multiple users."""
  users(
    """Filters by name. Accepts SQL LIKE wildcards `%` and `_`."""
    name: String

    """Limits number of fetched items."""
    first: Int! = 10

    """The offset from which items are returned."""
    page: Int
  ): UserPaginator!
}

"""Order by clause for Query.orders.orderBy."""
input QueryOrdersOrderByOrderByClause {
  """The column that is used for ordering."""
  column: OrderOrderByField!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Order by clause for Query.orderSteps.orderBy."""
input QueryOrderStepsOrderByOrderByClause {
  """The column that is used for ordering."""
  column: OrderStepOrderByField!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Order by clause for Query.rooms.orderBy."""
input QueryRoomsOrderByOrderByClause {
  """The column that is used for ordering."""
  column: RoomOrderByField!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Order by clause for Query.stepMenus.orderBy."""
input QueryStepMenusOrderByOrderByClause {
  """The column that is used for ordering."""
  column: StepMenuOrderByField!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Order by clause for Query.tables.orderBy."""
input QueryTablesOrderByOrderByClause {
  """The column that is used for ordering."""
  column: TableOrderByField!

  """The direction that is used for ordering."""
  order: SortOrder!
}

"""Bouton d’accès rapide configurable pour une entreprise."""
type QuickAccess {
  """Identifiant unique."""
  id: ID!

  """Position (1..5) au sein de l’entreprise."""
  index: Int!

  """Libellé du bouton."""
  name: String!

  """Nom de l’icône (ex: Plus, Notebook, Minus, Calendar, Check)."""
  icon: String!

  """Couleur de l’icône (ex: primary, warning, error, info)."""
  icon_color: String!

  """Clé d'URL cible du bouton (route logique)."""
  url_key: String!

  """Entreprise propriétaire."""
  company: Company!

  """Date de création."""
  created_at: DateTime!

  """Date de mise à jour."""
  updated_at: DateTime!
}

type Room {
  """Unique primary key."""
  id: ID!
  name: String!
  code: String!
  company: Company!
  tables: [Table!]!
  created_at: DateTime!
  updated_at: DateTime!
}

enum RoomOrderByField {
  ID
  NAME
  CODE
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of Room items."""
type RoomPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Room items."""
  data: [Room!]!
}

union SearchResult = Ingredient | Preparation

"""Directions for ordering a list of records."""
enum SortOrder {
  """Sort records in ascending order."""
  ASC

  """Sort records in descending order."""
  DESC
}

"""Association entre une étape de commande et un menu."""
type StepMenu {
  """Identifiant unique."""
  id: ID!

  """Étape de commande liée."""
  step: OrderStep!

  """Menu associé à cette ligne."""
  menu: Menu!

  """Quantité commandée."""
  quantity: Int!

  """Statut de la ligne de menu."""
  status: StepMenuStatusEnum!

  """Note éventuelle ajoutée par l'équipe."""
  note: String

  """Horodatage du service de ce menu."""
  served_at: DateTime

  """Date de création de la ligne."""
  created_at: DateTime!

  """Date de dernière mise à jour."""
  updated_at: DateTime!
}

"""Options de tri disponibles pour les menus d'une étape."""
input StepMenuOrderByClause {
  """Colonne utilisée pour le tri."""
  column: StepMenuOrderByField!

  """Direction du tri."""
  order: SortOrder! = ASC
}

"""Colonnes triables pour les menus d'une étape."""
enum StepMenuOrderByField {
  ID
  ORDER_STEP_ID
  MENU_ID
  QUANTITY
  STATUS
  SERVED_AT
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of StepMenu items."""
type StepMenuPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of StepMenu items."""
  data: [StepMenu!]!
}

enum StepMenuStatusEnum {
  IN_PREP
  READY
  SERVED
}

"""Représente un mouvement de stock d'un ingrédient ou d'une préparation."""
type StockMovement {
  """Identifiant unique."""
  id: ID!

  """Type d'entité concernée par ce mouvement (ingredient ou preparation)."""
  trackable_type: String!

  """ID de l'entité concernée."""
  trackable_id: ID!

  """L'emplacement où le mouvement a eu lieu."""
  location: Location!

  """L'entreprise à laquelle appartient ce mouvement."""
  company: Company!

  """L'utilisateur qui a effectué l'opération."""
  user: User

  """Type de mouvement: 'addition', 'withdrawal' ou 'movement'."""
  type: String!

  """Raison du mouvement."""
  reason: String

  """Quantité concernée par le mouvement (toujours positive)."""
  quantity: Float!

  """Quantité avant le mouvement."""
  quantity_before: Float

  """Quantité après le mouvement."""
  quantity_after: Float

  """Date et heure de création du mouvement."""
  created_at: DateTime!

  """Date et heure de dernière mise à jour du mouvement."""
  updated_at: DateTime!
}

"""Options de tri pour les mouvements de stock."""
input StockMovementOrderByClause {
  """Champ sur lequel effectuer le tri."""
  column: StockMovementOrderByField!

  """Direction du tri."""
  order: SortOrder!
}

"""Champs disponibles pour le tri des mouvements de stock."""
enum StockMovementOrderByField {
  ID
  TYPE
  QUANTITY
  QUANTITY_BEFORE
  QUANTITY_AFTER
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of StockMovement items."""
type StockMovementPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of StockMovement items."""
  data: [StockMovement!]!
}

type Table {
  """Unique primary key."""
  id: ID!
  label: String!
  seats: Int!
  room: Room!
  orders: [Order!]
  created_at: DateTime!
  updated_at: DateTime!
}

enum TableOrderByField {
  ID
  LABEL
  SEATS
  ROOM_ID
  CREATED_AT
  UPDATED_AT
}

"""A paginated list of Table items."""
type TablePaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Table items."""
  data: [Table!]!
}

"""
Specify if you want to include or exclude trashed results from a query.
"""
enum Trashed {
  """Only return trashed results."""
  ONLY

  """Return both trashed and non-trashed results."""
  WITH

  """Only return non-trashed results."""
  WITHOUT
}

enum UnitEnum {
  kg
  hg
  dag
  g
  dg
  cg
  mg
  kL
  hL
  daL
  L
  dL
  cL
  mL
  unit
}

"""Account of a person who uses this application."""
type User {
  """Unique primary key."""
  id: ID!

  """The company this user belongs to."""
  company: Company

  """Non-unique name."""
  name: String!

  """Unique email address."""
  email: String!

  """When the email was verified."""
  email_verified_at: DateTime

  """When the account was created."""
  created_at: DateTime!

  """When the account was last updated."""
  updated_at: DateTime!
}

"""A paginated list of User items."""
type UserPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of User items."""
  data: [User!]!
}

